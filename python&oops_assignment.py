# -*- coding: utf-8 -*-
"""Python&OOPS_Assignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Be9APgIsKoqvBnkhe628NyKx8Y3XRBDq
"""

# What is the difference between list and tuple in Python?

# In list :-1-it allows duplicate elements
#           2-it is changable (mutable)
#           3-it is ordered form
#           4-it is used in []
# Tuple:-1-it allows duplicate elements
#           2-it is unchangable (immutable)
#           3-it is ordered form
#           4-it is used in ()

# Explain the concept of PEP 8

# It improve the readability and consistency of python

# What is the purpose of the __init__ method in Python classes?

# the main purpose of __init__ method to insialized the variables and it is automatically called

# How does inheritance work in Python? Provide an example.

# when a class derives from another class. the child class will inherits all the public and protected properties and methods from the parent class

class person:
  def __init__(self,fname,sscore):
    self.firstname=fname
    self.superscore=sscore
  def printname(self):
    print(self.firstname, self.superscore)

x=person("Nupriya","112")
x.printname()

# Explain the difference between staticmethod and classmethod.

# static method is within a class that have no access to anything else in the class
# but in class methods within a class that only have access to class variables and other class methods

class func1:
  def __init__(self):
    self.x=x

  def staticmethod():
    return "static"

class func1:
  count=0
  def __init__(self):
    self.x=x

  def classmethod(cls):
    cls.count +=1

# What is Polymorphism in Python? Give an example.

# Polymorphism -> poly means many and morphism means form
# it refers to use the same functions name , but with different signatures, for multiple type
class bird():
  def __init__(self,color):
    self.color = color
  def features(self):
    print("can fly", self.color)
class ostrich():
  def __init__(self,color):
    self.color=color
  def features(self):
    print("can't fly", self.color)

def create_object(object):
    object.features()

create_object(bird("green"))
create_object(ostrich("black and white"))

# How do you handle exceptions in Python?

# The try and except block in Python is used to catch and handle exceptions. Python executes code following the try statement
# as a “normal” part of the program. The code that
# follows the except statement is the program's response to any exceptions in the preceding try clause

# Explain the Global Interpreter Lock (GIL) in Python

#it is a multithreading programming. process lock used when working with multiple processes.
#It gives the control to only one thread.Generally, Python uses a single thread to run a single process.
#We get the same performance result of the single-threaded and multi-threaded processes using the GIL.

#What is a decorator in Python? Provide an example.

#it allows programmers to modify the behaviour of a function or class.
#it allow us to wrap another function in order to extend the behaviour of the wrapped function, without permanently modifying it.
def deco(func):
    def inner():
        print("before function execution")
        func()
        print("after function execution")
    return inner
def func_used():
    print("inside the function")
func_used = deco(func_used)
func_used()

#How do you implement encapsulation in Python?

#wrapping data and the methods that work on data within one unit.

class students:
  def __init__(self,name,score):
    self.name=name
    self.score=score
  def demo(self):
    print("I am ",self.name)
    print("I score",self.score)
st1=students("nupriya",99)
st2=students("priya",100)
st1.demo()
st2.demo()

#Explain the concept of duck typing.
#Duck typing is a concept related to dynamic typing, where the type or the class of an object is less important than the methods it defines.
#When you use duck typing, you do not check types at all. Instead, you check for the presence of a given method or attribute.

class Bird:
    def action(self):
        print("fly with wings")
class Airplane:
    def action(self):
        print("fly with fuel")
class Fish:
    def action(self):
        print("fish swim in sea")
for obj in Bird(), Airplane(), Fish():
  obj.action()

#What is the difference between append() and extend() methods for lists?

#The append() method adds a single element to the end of the list.
#The extend() method takes one argument, a list, and appends each of the items of the argument to the original list.

list1 = [1, 2, 3]
list2 = [4, 5, 6]
list1.append(7)
print(list1)
list1.extend(list2)
print(list1)

#How does the with statement work in Python?

#with statement is used in exception handling to make the code cleaner and much more readable.
#It simplifies the management of common resources like file streams.

with open('file_path', 'w') as file:
    file.write('hello world')

#Discuss the use of self in Python classes.

#SELF represents the instance of class. This allows you to access variables, attributes, and methods of a defined class in Python.

#Explain the purpose of the _slots_ attribute.

#The __slots__ attribute is a special attribute in Python that allows you to explicitly state
# which instance attributes you expect your object instances to have.

class GFG(object):
      __slots__=['a', 'b']
      def __init__(self, *args, **kwargs):
                self.a = 1
                self.b = 2

instance = GFG()
print(instance.__slots__)

#What is the difference between an instance variable and a class variable?

#class variables are shared among all instances of a class, while instance variables are unique to each instance.
#Class variables are declared within a class but outside of any methods. They are shared among all instances of the class and
#can be accessed using the class name.

#How do you implement Encapsulation, Abstraction, Polymorphism?

# polymorphism
class bird():
  def __init__(self,color):
    self.color = color
  def features(self):
    print("can fly", self.color)
class ostrich():
  def __init__(self,color):
    self.color=color
  def features(self):
    print("can't fly", self.color)

def create_object(object):
    object.features()

create_object(bird("green"))
create_object(ostrich("black and white"))

# encapsulation

class students:
  def __init__(self,name,score):
    self.name=name
    self.score=score
  def demo(self):
    print("I am ",self.name)
    print("I score",self.score)
st1=students("nupriya",99)
st2=students("priya",100)
st1.demo()
st2.demo()

# Abstraction

#ABC is abstract class
class employee(ABC):
  def emp_id(self,id,name,age):
    pass
class childEmployee(employee):
  def emp_id(self,id):
    print("emp_id is 1")
emp1=childEmployee()
emp1.emp_id(id)

#How do you Implement single level Inheritance, multiple level inheritance, multi level inheritance, Hybrid Inheritance

#single inheritance
class Parent:
    def func1(self):
        print("parent class.")
class Child(Parent):
    def func2(self):
        print("child class.")
object = Child()
object.func1()
object.func2()

#Multiple inheritance
class Mother:
    mothername = ""
    def mother(self):
        print(self.mothername)
class Father:
    fathername = ""
    def father(self):
        print(self.fathername)
class Son(Mother, Father):
    def parents(self):
        print("Father :", self.fathername)
        print("Mother :", self.mothername)
s1 = Son()
s1.fathername = "RAM"
s1.mothername = "SITA"
s1.parents()

#MultiLevel inheritance
class Grandfather:
    def __init__(self, grandfathername):
        self.grandfathername = grandfathername
class Father(Grandfather):
    def __init__(self, fathername, grandfathername):
        self.fathername = fathername
        Grandfather.__init__(self, grandfathername)
class Son(Father):
    def __init__(self, sonname, fathername, grandfathername):
        self.sonname = sonname
        Father.__init__(self, fathername, grandfathername)
    def print_name(self):
        print('Grandfather name :', self.grandfathername)
        print("Father name :", self.fathername)
        print("Son name :", self.sonname)
s1 = Son('Shrey', 'sharad', 'Arun')
print(s1.grandfathername)
s1.print_name()

#Hybrid inheritance

class School:
    def func1(self):
        print("function of school.")
class Student1(School):
    def func2(self):
        print("function of student 1. ")
class Student2(School):
    def func3(self):
        print("function of student 2.")
class Student3(Student1, School):
    def func4(self):
        print("function of student 3.")
object = Student3()
object.func1()
object.func2()